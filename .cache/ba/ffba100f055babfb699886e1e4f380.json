{"id":"../node_modules/ip-num/BinaryUtils.js","dependencies":[{"name":"/home/user/Desktop/ip tracker/node_modules/ip-num/BinaryUtils.js.map","includedInParent":true,"mtime":1655295187963},{"name":"/home/user/Desktop/ip tracker/package.json","includedInParent":true,"mtime":1655298118967},{"name":"/home/user/Desktop/ip tracker/node_modules/ip-num/package.json","includedInParent":true,"mtime":1655295187959}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchingBitCount = exports.intLog2 = exports.cidrPrefixToMaskBinaryString = exports.leftPadWithZeroBit = exports.dottedDecimalNotationToBinaryString = exports.parseBinaryStringToBigInt = exports.decimalNumberToOctetString = exports.numberToBinaryString = void 0;\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\nexports.numberToBinaryString = (num) => {\n    return num.toString(2);\n};\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexports.decimalNumberToOctetString = (num) => {\n    let binaryString = exports.numberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\");\n    }\n    return exports.leftPadWithZeroBit(binaryString, 8);\n};\n/**\n * Parses number in binary to number in BigInt\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInt\n */\nexports.parseBinaryStringToBigInt = (num) => {\n    return BigInt(`0b${num}`);\n};\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexports.dottedDecimalNotationToBinaryString = (dottedDecimal) => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(exports.decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexports.leftPadWithZeroBit = (binaryString, finalStringLength) => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than given final length after padding: ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n/**\n * Given the prefix portion of a cidr notation and the type of IP number, returns the mask in binary string\n *\n * @param {number} cidrPrefix the prefix part of a cidr notation\n * @param {IPNumType.IPv4 | IPNumType.IPv6} ipType the type of the ip number in the range the cidr represents\n */\nexports.cidrPrefixToMaskBinaryString = (cidrPrefix, ipType) => {\n    let cidrUpperValue;\n    if (ipType == \"IPv4\" /* IPv4 */) {\n        cidrUpperValue = 32;\n    }\n    else {\n        cidrUpperValue = 128;\n    }\n    if (cidrPrefix > cidrUpperValue)\n        throw Error(`Value is greater than ${cidrUpperValue}`);\n    let onBits = '1'.repeat(cidrPrefix);\n    let offBits = '0'.repeat(cidrUpperValue - cidrPrefix);\n    return `${onBits}${offBits}`;\n};\n/**\n * Calculates the log, to base 2 of given number.\n *\n * @throws Error if number cannot be converted to log base 2\n * @param givenNumber the number to calculate log base 2\n * @return the log base 2 of given number\n */\nexports.intLog2 = (givenNumber) => {\n    let result = 0;\n    while (givenNumber % 2n === 0n) {\n        if (givenNumber === 2n) {\n            result++;\n            break;\n        }\n        givenNumber = givenNumber >> 1n;\n        if (givenNumber % 2n !== 0n) {\n            result = 0;\n            break;\n        }\n        result++;\n    }\n    if (result == 0) {\n        throw new Error(`The value of log2 for ${givenNumber.toString()} is not an integer`);\n    }\n    return result;\n};\n/**\n * Starting from the most significant bit (from left) returns the number of first bits from both string that are equal\n * @param firstBinaryString first binary string\n * @param secondBinaryString second binary string\n */\nexports.matchingBitCount = (firstBinaryString, secondBinaryString) => {\n    let longerString;\n    let otherString;\n    if (firstBinaryString.length >= secondBinaryString.length) {\n        longerString = firstBinaryString;\n        otherString = secondBinaryString;\n    }\n    else {\n        longerString = secondBinaryString;\n        otherString = firstBinaryString;\n    }\n    let count = 0;\n    for (; count < longerString.length; count++) {\n        if (longerString.charAt(count) === otherString.charAt(count)) {\n            continue;\n        }\n        break;\n    }\n    return count;\n};\n"},"sourceMaps":{"js":{"version":3,"file":"BinaryUtils.js","sourceRoot":"","sources":["../../src/BinaryUtils.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"83bfbc23a81431723624b2d41ac7c582","cacheData":{"env":{}}}